# 说明
1.JVM（Java虚拟机）栈帧的内部结构是虚拟机栈中的一个重要概念，它用于支持虚拟机进行方法调用和执行。

2.每个方法从调用到执行完成的过程，都对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

3.栈帧中存储了方法执行过程中的各种数据信息。
4.每个栈帧都有自己的大小，且各个栈帧的大小可能不同，这取决于里面存储的数据的大小。

5.在多线程环境下，每个线程都有自己的虚拟机栈，栈中存储的是各自的栈帧，它们之间互不影响。

6.总的来说，JVM栈帧的内部结构是虚拟机进行方法调用和执行的基础，它通过局部变量表、操作数栈、动态链接、方法返回地址等部分，维系着方法执行过程中的各种数据信息。

![image](https://github.com/user-attachments/assets/c09e5030-d7da-439b-9ce7-f138cd565207)

# 局部变量表（Local Variables）

![image](https://github.com/user-attachments/assets/9c9b9a5f-51f3-45cf-a858-f8538aa184a7)


![image](https://github.com/user-attachments/assets/2ff2fbc3-58a2-40a3-b373-0908d9ee6d79)
局部变量表大概如下所示：

1.0位置：每个方法的局部变量表，第一个位置必须是this。
2.方法参数列表：方法参数列表排在this后面。
3.方法内部创建的变量：方法内部创建变量排在方法参数列表后面。譬如我们在方法里声明了一个int值，那么在局部变量表后面就会新增一个slot，存储这个int变量。但是需要注意的是，如果你只是new Object，却并没有定义变量，那么是不会增加slot的。

需要注意的是，int、boolean、char、Object这种都只占一个slot，如果遇到long或者double类型的，则占用两个slot来存储。


1.定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量，这些数据类型包括各类基本数据类型、对象引用（reference），以及returnAddress返回值类型。

2.由于局部变量表是建立在线程的栈上，是线程的私有数据，因此不存在数据安全问题

3.局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。

4.方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。

5.对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。

6.局部变量表中的变量只在当前方法调用中有效。

7.在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。

8.当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁

局部变量表（Local Variable Table）是一组变值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在放的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。 局部变量表的容量以变量槽（Variable Slot）为最小单位。每个Slot都应该能存放一个boolean、byte、char、short、int、float、reference、或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存放。Slot的长度可以随着处理器、操作系统或虚拟机的不同而发生变化。

## reference类型
reference类型类型表示对一个对象实例的引用。虚拟机规范既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但一般说来，虚拟机实现至少都是通过这个引用做到两点，一是从此引用中直接或间接地查到对象在Java堆中的数据存放地址索引，二是引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息，否则无法实现Java语言规范中定义的语法约束。

它表示了一个对象实例的引用（堆中），主要的作用有两个：

1.能根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址和索引

2.能根据引用直接或间接地查找到对象所属数据类型在元空间种的存储类型信息

## 64位数据类型（long、double）
对于64位的数据类型，虚拟机以高位对齐的方式为其分配两个连续的Slot空间。Java语言中明确的（reference类型则可能是32位也可能是64位）64位的数据类型只有long和double两种。由于局部变量表建立在线程的堆栈上，是线程私有的数据，无论读写两个连续的Slot是否为原子操作，都不会引起数据安全问题。

变量如何在局部变量表中存储的
通过以上描述，我们知道它是以变量槽的方式进行存储。具体流程我们通过下面代码进行分析

```
public void show() {
        String name = "张三";
        int age = 20;
    }
```

对应的字节码文件

```
0 ldc #5 <张三>
2 astore_1
3 bipush 20
5 istore_2
6 return
```

现在分析字节码文件的执行流程

ldc #5 <张三>
将 张三 的值压栈

astore_1
将 张三 弹出栈并将该值的引用赋予变量槽1的位置。因为字符串是在堆中的，需要引用指向

bipush 20
将 20 压入栈

istore_2
将 20 弹出栈，并将该值赋予变量槽2的位置。因为符合变量槽的要求，所以该值在变量槽中

通过以上得出，String是以引用refrence在变量槽中存放的。int 则是值在变量槽中存放的。

为方便理解，画了一个图：

![image](https://github.com/user-attachments/assets/53b2170d-d0d0-40ec-abcb-85512f9abc15)

## 关于Slot的理解

参数值的存放总是在局部变量数组的index 0开始，到 数组长度-1 的索引结束；
局部变量表，最基本的存储单元是Slot（变量槽）；
局部变量表中存放编译期可知的各种基本数据类型（8种），引用类型，returnAddress类型的变量；
在局部变量表里，32位以内的类型只占用一个Slot（包括引用类型），64位的类型（long和double）占用两个Slot；
byte、short、char在存储前被转换为int，boolean也被转换为int；
long和double则占据两个Slot。
JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值；
当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上；
如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。（比如访问long或double类型变量）
如果当前帧是由构造方法或实例方法创建的 ，那么该对象引用this将会存放在index为0的Slot处，其余的参数按照参数表顺序继续排列。

![image](https://github.com/user-attachments/assets/9c1b8137-0874-4313-866b-03d09b084c51)

## Slot的重复利用（踩坑点）
栈帧中的局部变量表中的槽位是可以重用的，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。

例：在test4()方法中，局部变量个数为3 —》this，a 和 c ，因为变量b只在其作用域中有效，变量b被销毁，但开辟的空间还在，新定义的变量c就占据了这块已开辟的空间。

![image](https://github.com/user-attachments/assets/35dce6a8-23ae-4f59-87f0-9e47f3255214)


# 操作数栈（Operand Stack）
1.操作数栈是一个后进先出（LIFO）栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间。

2.在方法执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，即入栈和出栈操作。

3.操作数栈所需的最大深度在编译期就确定下来，并保存在方法的Code属性的max_stacks项中。

4.操作数栈中的元素可以是任意的Java数据类型，32位数据类型在栈中占一个单位深度，64位数据类型占两个单位深度。

# 动态链接（Dynamic Linking）
1.每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，此引用用于支持方法调用过程中的动态链接。
2.动态链接将Class文件中常量池的符号引用转为直接引用，这个过程在方法运行期间进行。

# 方法返回地址（Return Address）
1.方法返回地址也被称为方法退出或者异常退出的定义，它存储了方法执行完成后，返回到哪个位置继续执行的信息。
2.无论是正常的方法返回还是异常的方法返回，都需要恢复到上层方法的执行状态，继续执行。
